#' Prepare rank or preference data for further analyses
#'
#' @param rankings A matrix of ranked items, of size `n_assessors x
#'   n_items`. See [create_ranking()] if you have an ordered set of
#'   items that need to be converted to rankings. If `preferences` is
#'   provided, `rankings` is an optional initial value of the rankings,
#'   generated by [generate_initial_ranking()]. If `rankings` has
#'   column names, these are assumed to be the names of the items. `NA`
#'   values in rankings are treated as missing data and automatically augmented;
#'   to change this behavior, see the `na_action` argument to
#'   [set_model_options()].
#'
#' @param preferences A data frame with one row per pairwise comparison, and
#'   columns `assessor`, `top_item`, and `bottom_item`. Each
#'   column contains the following:
#' \itemize{
#' \item `assessor` is a numeric vector containing the assessor index, or a character
#'       vector containing the (unique) name of the assessor.
#'
#' \item `bottom_item` is a numeric vector containing the index of the item that
#'       was disfavored in each pairwise comparison.
#'
#' \item `top_item` is a numeric vector containing the index of the item that was
#'       preferred in each pairwise comparison.
#' }
#'   So if we have two assessors and five items, and assessor 1 prefers item 1
#'   to item 2 and item 1 to item 5, while assessor 2 prefers item 3 to item 5,
#'   we have the following `df`:
#' \tabular{rrr}{
#' **assessor** \tab **bottom_item** \tab **top_item**\cr
#' 1 \tab 2 \tab 1\cr
#' 1 \tab 5 \tab 1\cr
#' 2 \tab 5 \tab 3\cr
#' }
#'
#' @param obs_freq A vector of observation frequencies (weights) to apply do
#'   each row in `rankings`. This can speed up computation if a large
#'   number of assessors share the same rank pattern. Defaults to `NULL`,
#'   which means that each row of `rankings` is multiplied by 1. If
#'   provided, `obs_freq` must have the same number of elements as there
#'   are rows in `rankings`, and `rankings` cannot be `NULL`. See
#'   [obs_freq()] for more information and
#'   [rank_freq_distr()] for a convenience function for computing it.
#'
#' @param validate_rankings Logical specifying whether the rankings provided (or
#'   generated from `preferences`) should be validated. Defaults to
#'   `TRUE`. Turning off this check will reduce computing time with a large
#'   number of items or assessors.
#'
#' @param na_action Character specifying how to deal with `NA` values in
#'   the `rankings` matrix, if provided. Defaults to `"augment"`,
#'   which means that missing values are automatically filled in using the
#'   Bayesian data augmentation scheme described in
#'   \insertCite{vitelli2018;textual}{BayesMallows}. The other options for this
#'   argument are `"fail"`, which means that an error message is printed
#'   and the algorithm stops if there are `NA`s in `rankings`, and
#'   `"omit"` which simply deletes rows with `NA`s in them.
#'
#' @param cl Optional computing cluster used for parallelization when generating
#'   transitive closure based on preferences, returned from
#'   [parallel::makeCluster()]. Defaults to `NULL`.
#'
#' @param ... Other optional arguments, forwarded to
#'   [generate_initial_ranking()].
#'
#'
#' @return An object of class `"BayesMallowsData"`, to be provided in the
#'   `data` argument to [compute_mallows()].
#' @export
#'
#' @family options
#'
setup_rank_data <- function(
    rankings = NULL,
    preferences = NULL,
    obs_freq = NULL,
    validate_rankings = TRUE,
    na_action = "augment",
    cl = NULL,
    ...
) {

  na_action <- match.arg(na_action, c("augment", "fail", "omit"))

  if (is.null(rankings) && is.null(preferences)) {
    stop("Either rankings or preferences (or both) must be provided.")
  }

  if(is.null(rankings)) {
    n_items <- max(preferences[, c("bottom_item", "top_item")])
  } else {
    n_items <- ncol(rankings)
  }
  preferences <- tryCatch({
    generate_transitive_closure(preferences, cl)
  },
  error = function(e) {
    ret <- preferences
    class(ret) <- c("BayesMallowsIntransitive", class(ret))
    message("Preferences are intransitive. Make sure to run compute_mallows() ",
            "with an appropriate error model.")
    ret
  })

  # Check if there are NAs in rankings, if it is provided
  if (!is.null(rankings)) {
    if (na_action == "fail" && any(is.na(rankings))) {
      stop("rankings matrix contains NA values")
    }

    if (na_action == "omit" && any(is.na(rankings))) {
      keeps <- apply(rankings, 1, function(x) !any(is.na(x)))
      print(paste("Omitting", sum(keeps), "rows from rankings due to NA values"))
      rankings <- rankings[keeps, , drop = FALSE]
    }
  } else {
    rankings <- generate_initial_ranking(preferences, n_items, cl, ...)
  }

  # Check if obs_freq are provided
  if (!is.null(obs_freq)) {
    validate_positive_vector(obs_freq)
    if (is.null(rankings)) {
      stop("rankings matrix must be provided when obs_freq are provided")
    }
    if (nrow(rankings) != length(obs_freq)) {
      stop("obs_freq must be of same length as the number of rows in rankings")
    }
  }

  # Check that all rows of rankings are proper permutations
  if (validate_rankings &&
      !all(apply(rankings, 1, validate_permutation))) {
    stop("invalid permutations provided in rankings matrix")
  }

  ret <- as.list(environment())
  class(ret) <- "BayesMallowsData"
  ret

}

