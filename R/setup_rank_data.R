#' Prepare rank or preference data for further analyses
#'
#' @param rankings A matrix of ranked items, of size \code{n_assessors x
#'   n_items}. See \code{\link{create_ranking}} if you have an ordered set of
#'   items that need to be converted to rankings. If \code{preferences} is
#'   provided, \code{rankings} is an optional initial value of the rankings,
#'   generated by \code{\link{generate_initial_ranking}}. If \code{rankings} has
#'   column names, these are assumed to be the names of the items. \code{NA}
#'   values in rankings are treated as missing data and automatically augmented;
#'   to change this behavior, see the \code{na_action} argument to
#'   \code{\link{set_model_options}}.
#'
#' @param preferences A data frame with one row per pairwise comparison, and
#'   columns \code{assessor}, \code{top_item}, and \code{bottom_item}. Each
#'   column contains the following:
#' \itemize{
#' \item \code{assessor} is a numeric vector containing the assessor index, or a character
#'       vector containing the (unique) name of the assessor.
#'
#' \item \code{bottom_item} is a numeric vector containing the index of the item that
#'       was disfavored in each pairwise comparison.
#'
#' \item \code{top_item} is a numeric vector containing the index of the item that was
#'       preferred in each pairwise comparison.
#' }
#'   So if we have two assessors and five items, and assessor 1 prefers item 1
#'   to item 2 and item 1 to item 5, while assessor 2 prefers item 3 to item 5,
#'   we have the following \code{df}:
#' \tabular{rrr}{
#' \strong{assessor} \tab \strong{bottom_item} \tab \strong{top_item}\cr
#' 1 \tab 2 \tab 1\cr
#' 1 \tab 5 \tab 1\cr
#' 2 \tab 5 \tab 3\cr
#' }
#'
#' @param obs_freq A vector of observation frequencies (weights) to apply do
#'   each row in \code{rankings}. This can speed up computation if a large
#'   number of assessors share the same rank pattern. Defaults to \code{NULL},
#'   which means that each row of \code{rankings} is multiplied by 1. If
#'   provided, \code{obs_freq} must have the same number of elements as there
#'   are rows in \code{rankings}, and \code{rankings} cannot be \code{NULL}. See
#'   \code{\link{obs_freq}} for more information and
#'   \code{\link{rank_freq_distr}} for a convenience function for computing it.
#'
#' @param validate_rankings Logical specifying whether the rankings provided (or
#'   generated from \code{preferences}) should be validated. Defaults to
#'   \code{TRUE}. Turning off this check will reduce computing time with a large
#'   number of items or assessors.
#'
#' @param na_action Character specifying how to deal with \code{NA} values in
#'   the \code{rankings} matrix, if provided. Defaults to \code{"augment"},
#'   which means that missing values are automatically filled in using the
#'   Bayesian data augmentation scheme described in
#'   \insertCite{vitelli2018;textual}{BayesMallows}. The other options for this
#'   argument are \code{"fail"}, which means that an error message is printed
#'   and the algorithm stops if there are \code{NA}s in \code{rankings}, and
#'   \code{"omit"} which simply deletes rows with \code{NA}s in them.
#'
#' @param cl Optional computing cluster used for parallelization when generating
#'   transitive closure based on preferences, returned from
#'   \code{parallel::makeCluster}. Defaults to \code{NULL}.
#'
#' @param ... Other optional arguments, forward to
#'   \code{\link{generate_initial_ranking}}.
#'
#'
#' @return An object of class \code{"BayesMallowsData"}, to be provided in the
#'   \code{data} argument to \code{\link{compute_mallows}}.
#' @export
#'
#' @family options
#'
setup_rank_data <- function(
    rankings = NULL,
    preferences = NULL,
    obs_freq = NULL,
    validate_rankings = TRUE,
    na_action = "augment",
    cl = NULL,
    ...
) {

  na_action <- match.arg(na_action, c("augment", "fail", "omit"))

  if (is.null(rankings) && is.null(preferences)) {
    stop("Either rankings or preferences (or both) must be provided.")
  }

  if(is.null(rankings)) {
    n_items <- max(preferences[, c("bottom_item", "top_item")])
  } else {
    n_items <- ncol(rankings)
  }
  preferences <- tryCatch({
    generate_transitive_closure(preferences, cl)
  },
  error = function(e) {
    ret <- preferences
    class(ret) <- c("BayesMallowsIntransitive", class(ret))
    message("Preferences are intransitive. Make sure to run compute_mallows() ",
            "with an appropriate error model.")
    ret
  })

  # Check if there are NAs in rankings, if it is provided
  if (!is.null(rankings)) {
    if (na_action == "fail" && any(is.na(rankings))) {
      stop("rankings matrix contains NA values")
    }

    if (na_action == "omit" && any(is.na(rankings))) {
      keeps <- apply(rankings, 1, function(x) !any(is.na(x)))
      print(paste("Omitting", sum(keeps), "rows from rankings due to NA values"))
      rankings <- rankings[keeps, , drop = FALSE]
    }
  } else {
    rankings <- generate_initial_ranking(preferences, n_items, cl, ...)
  }

  # Check if obs_freq are provided
  if (!is.null(obs_freq)) {
    validate_positive_vector(obs_freq)
    if (is.null(rankings)) {
      stop("rankings matrix must be provided when obs_freq are provided")
    }
    if (nrow(rankings) != length(obs_freq)) {
      stop("obs_freq must be of same length as the number of rows in rankings")
    }
  }

  # Check that all rows of rankings are proper permutations
  if (validate_rankings &&
      !all(apply(rankings, 1, validate_permutation))) {
    stop("invalid permutations provided in rankings matrix")
  }

  ret <- as.list(environment())
  class(ret) <- "BayesMallowsData"
  ret

}

