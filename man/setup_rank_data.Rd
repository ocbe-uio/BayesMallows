% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setup_rank_data.R
\name{setup_rank_data}
\alias{setup_rank_data}
\title{Prepare rank or preference data for further analyses}
\usage{
setup_rank_data(
  rankings = NULL,
  preferences = NULL,
  observation_frequency = NULL,
  validate_rankings = TRUE,
  na_action = "augment",
  cl = NULL,
  shuffle_unranked = FALSE,
  random = FALSE,
  random_limit = 8L
)
}
\arguments{
\item{rankings}{A matrix of ranked items, of size \verb{n_assessors x n_items}.
See \code{\link[=create_ranking]{create_ranking()}} if you have an ordered set of items that need to be
converted to rankings. If \code{preferences} is provided, \code{rankings} is an
optional initial value of the rankings. If \code{rankings} has column names,
these are assumed to be the names of the items. \code{NA} values in rankings are
treated as missing data and automatically augmented; to change this
behavior, see the \code{na_action} argument to \code{\link[=set_model_options]{set_model_options()}}.}

\item{preferences}{A data frame with one row per pairwise comparison, and
columns \code{assessor}, \code{top_item}, and \code{bottom_item}. Each column contains the
following:
\itemize{
\item \code{assessor} is a numeric vector containing the assessor index, or a character
vector containing the (unique) name of the assessor.

\item \code{bottom_item} is a numeric vector containing the index of the item that
was disfavored in each pairwise comparison.

\item \code{top_item} is a numeric vector containing the index of the item that was
preferred in each pairwise comparison.
}
So if we have two assessors and five items, and assessor 1 prefers item 1
to item 2 and item 1 to item 5, while assessor 2 prefers item 3 to item 5,
we have the following \code{df}:
\tabular{rrr}{
\strong{assessor} \tab \strong{bottom_item} \tab \strong{top_item}\cr
1 \tab 2 \tab 1\cr
1 \tab 5 \tab 1\cr
2 \tab 5 \tab 3\cr
}}

\item{observation_frequency}{A vector of observation frequencies (weights) to apply do
each row in \code{rankings}. This can speed up computation if a large number of
assessors share the same rank pattern. Defaults to \code{NULL}, which means that
each row of \code{rankings} is multiplied by 1. If provided, \code{observation_frequency} must
have the same number of elements as there are rows in \code{rankings}, and
\code{rankings} cannot be \code{NULL}. See \code{\link[=compute_observation_frequency]{compute_observation_frequency()}} for a convenience
function for computing it.}

\item{validate_rankings}{Logical specifying whether the rankings provided (or
generated from \code{preferences}) should be validated. Defaults to \code{TRUE}.
Turning off this check will reduce computing time with a large number of
items or assessors.}

\item{na_action}{Character specifying how to deal with \code{NA} values in the
\code{rankings} matrix, if provided. Defaults to \code{"augment"}, which means that
missing values are automatically filled in using the Bayesian data
augmentation scheme described in
\insertCite{vitelli2018;textual}{BayesMallows}. The other options for this
argument are \code{"fail"}, which means that an error message is printed and the
algorithm stops if there are \code{NA}s in \code{rankings}, and \code{"omit"} which simply
deletes rows with \code{NA}s in them.}

\item{cl}{Optional computing cluster used for parallelization when generating
transitive closure based on preferences, returned from
\code{\link[parallel:makeCluster]{parallel::makeCluster()}}. Defaults to \code{NULL}.}

\item{shuffle_unranked}{Logical specifying whether or not to randomly
permuted unranked items in the initial ranking. When
\code{shuffle_unranked=TRUE} and \code{random=FALSE}, all unranked items for each
assessor are randomly permuted. Otherwise, the first ordering returned by
\code{igraph::topo_sort()} is returned.}

\item{random}{Logical specifying whether or not to use a random initial
ranking. Defaults to \code{FALSE}. Setting this to \code{TRUE} means that all
possible orderings consistent with the stated pairwise preferences are
generated for each assessor, and one of them is picked at random.}

\item{random_limit}{Integer specifying the maximum number of items allowed
when all possible orderings are computed, i.e., when \code{random=TRUE}.
Defaults to \code{8L}.}
}
\value{
An object of class \code{"BayesMallowsData"}, to be provided in the \code{data}
argument to \code{\link[=compute_mallows]{compute_mallows()}}.
}
\description{
Prepare rank or preference data for further analyses
}
\note{
Setting \code{random=TRUE} means that all possible orderings of each
assessor's preferences are generated, and one of them is picked at random.
This can be useful when experiencing convergence issues, e.g., if the MCMC
algorithm does not mix properly. However, finding all possible orderings is
a combinatorial problem, which may be computationally very hard. The result
may not even be possible to fit in memory, which may cause the R session to
crash. When using this option, please try to increase the size of the
problem incrementally, by starting with smaller subsets of the complete
data. An example is given below.

It is assumed that the items are labeled starting from 1. For example, if a
single comparison of the following form is provided, it is assumed that
there is a total of 30 items (\code{n_items=30}), and the initial ranking is a
permutation of these 30 items consistent with the preference 29<30.

\tabular{rrr}{
\strong{assessor} \tab \strong{bottom_item} \tab \strong{top_item}\cr
1 \tab 29 \tab 30\cr
}

If in reality there are only two items, they should be relabeled to 1 and
2, as follows:

\tabular{rrr}{
\strong{assessor} \tab \strong{bottom_item} \tab \strong{top_item}\cr
1 \tab 1 \tab 2\cr
}
}
\seealso{
Other modeling: 
\code{\link{assess_convergence}()},
\code{\link{compute_mallows_mixtures}()},
\code{\link{compute_mallows}()},
\code{\link{set_compute_options}()},
\code{\link{set_initial_values}()},
\code{\link{set_model_options}()},
\code{\link{set_priors}()},
\code{\link{smc_mallows_new_item_rank}()},
\code{\link{smc_mallows_new_users}()}
}
\concept{modeling}
