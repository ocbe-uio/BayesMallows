% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setup_rank_data.R
\name{setup_rank_data}
\alias{setup_rank_data}
\title{Prepare rank or preference data for further analyses}
\usage{
setup_rank_data(
  rankings = NULL,
  preferences = NULL,
  obs_freq = NULL,
  validate_rankings = TRUE,
  na_action = "augment",
  cl = NULL,
  ...
)
}
\arguments{
\item{rankings}{A matrix of ranked items, of size \code{n_assessors x
n_items}. See \code{\link{create_ranking}} if you have an ordered set of
items that need to be converted to rankings. If \code{preferences} is
provided, \code{rankings} is an optional initial value of the rankings,
generated by \code{\link{generate_initial_ranking}}. If \code{rankings} has
column names, these are assumed to be the names of the items. \code{NA}
values in rankings are treated as missing data and automatically augmented;
to change this behavior, see the \code{na_action} argument to
\code{\link{set_model_options}}.}

\item{preferences}{A data frame with one row per pairwise comparison, and
  columns \code{assessor}, \code{top_item}, and \code{bottom_item}. Each
  column contains the following:
\itemize{
\item \code{assessor} is a numeric vector containing the assessor index, or a character
      vector containing the (unique) name of the assessor.

\item \code{bottom_item} is a numeric vector containing the index of the item that
      was disfavored in each pairwise comparison.

\item \code{top_item} is a numeric vector containing the index of the item that was
      preferred in each pairwise comparison.
}
  So if we have two assessors and five items, and assessor 1 prefers item 1
  to item 2 and item 1 to item 5, while assessor 2 prefers item 3 to item 5,
  we have the following \code{df}:
\tabular{rrr}{
\strong{assessor} \tab \strong{bottom_item} \tab \strong{top_item}\cr
1 \tab 2 \tab 1\cr
1 \tab 5 \tab 1\cr
2 \tab 5 \tab 3\cr
}}

\item{obs_freq}{A vector of observation frequencies (weights) to apply do
each row in \code{rankings}. This can speed up computation if a large
number of assessors share the same rank pattern. Defaults to \code{NULL},
which means that each row of \code{rankings} is multiplied by 1. If
provided, \code{obs_freq} must have the same number of elements as there
are rows in \code{rankings}, and \code{rankings} cannot be \code{NULL}. See
\code{\link{obs_freq}} for more information and
\code{\link{rank_freq_distr}} for a convenience function for computing it.}

\item{validate_rankings}{Logical specifying whether the rankings provided (or
generated from \code{preferences}) should be validated. Defaults to
\code{TRUE}. Turning off this check will reduce computing time with a large
number of items or assessors.}

\item{na_action}{Character specifying how to deal with \code{NA} values in
the \code{rankings} matrix, if provided. Defaults to \code{"augment"},
which means that missing values are automatically filled in using the
Bayesian data augmentation scheme described in
\insertCite{vitelli2018;textual}{BayesMallows}. The other options for this
argument are \code{"fail"}, which means that an error message is printed
and the algorithm stops if there are \code{NA}s in \code{rankings}, and
\code{"omit"} which simply deletes rows with \code{NA}s in them.}

\item{cl}{Optional computing cluster used for parallelization when generating
transitive closure based on preferences, returned from
[parallel::makeCluster()]. Defaults to \code{NULL}.}

\item{...}{Other optional arguments, forwarded to
\code{\link{generate_initial_ranking}}.}
}
\value{
An object of class \code{"BayesMallowsData"}, to be provided in the
  \code{data} argument to \code{\link{compute_mallows}}.
}
\description{
Prepare rank or preference data for further analyses
}
\seealso{
Other options: 
\code{\link{set_compute_options}()},
\code{\link{set_initial_values}()},
\code{\link{set_model_options}()},
\code{\link{set_priors}()}
}
\concept{options}
